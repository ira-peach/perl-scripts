#!/usr/bin/env perl

# PROGRAM_NAME - SHORT_PROGRAM_DESCRIPTION
# Copyright (C) 2024  Ira Peach
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use v5.36.0;
use warnings;
use strict;

use File::Basename;
use File::Find qw(find);
use File::Path qw(make_path);
use Getopt::Long qw(:config gnu_getopt no_ignore_case no_auto_abbrev);
use POSIX qw(strftime);

sub pp {
    use Data::Dumper;
    local $Data::Dumper::Indent = 1;
    print Dumper(@_);
}
# usage: pp $my_var;
# The below imports require installation of some packages.  Packages are listed
# for cygwin, then debian.

# perl-JSON-XS, libjson-xs-perl
#use JSON::XS qw(decode_json encode_json);

# perl-File-Slurp, libfile-slurp-perl
#use File::Slurp qw(read_file write_file);

# perl-YAML-LibYAML, libyaml-libyaml-perl
use YAML::XS qw(Dump Load);

# (none; use cpan), libfile-tee-perl
#use File::Tee qw(tee);

# (none; use cpan), libstring-shellquote-perl
#use String::ShellQuote qw(shell_quote);

# perl-IPC-System-Simple, libipc-system-simple-perl
#use IPC::System::Simple qw(capture capturex system systemx run runx $EXITVAL EXIT_ANY);

# perl-Capture-Tiny, libcapture-tiny-perl
#use Capture::Tiny qw(capture capture_stdout capture_stderr capture_merged tee tee_stdout tee_stderr tee_merged);

$| = 1;

my $now = time();
$now = strftime('%Y-%m-%d_%H%M%SZ', gmtime($now));

sub usage {
    my $prog = basename $0;
    say "usage: $prog KIND [OPTIONS]...";
    say "  SHORT_PROGRAM_DESCRIPTION";
    say "  -h,--help     display this usage and exit";
    say "  -c|--container  show containers on pods";
    say "  -d|--delete   delete matching resources of KIND";
    say "  -F|--field NUM=REGEX  match field NUM with REGEX (starting from 1)";
    say "  --follow  follow when given --logs";
    say "  -g|--get  get resource (default action)";
    say "  --getx  get resource, but do not process data in the program (used for debugging)";
    say "  --logs  get logs from kind pod";
    say "  -P|--preserve-columns  preserve fixed-width columns on output instead of converting to tab-separated value";
    say "  -s|--shell CONTAINER [ARGS]  shell into matched pod and CONTAINER";
    say "  -v,--verbose  add more verbose messaging";
}

sub get_containers {
    my ($namespace, $name) = @_;
    my $yaml = qx(kubectl get pod -n "$namespace" "$name" -o yaml);
    my $resource = Load $yaml;
    my @output = ();
    for my $container (@{$resource->{spec}{containers}}) {
        push @output, {
            namespace => $namespace,
            name => $name,
            container => $container,
        };
    }
    return @output;
}

my @args = ();
sub add_arg {
    push @args, @_;
}

my $action = "get";
my $container = "";
my $field_expr = "";
my %match_column;
my $follow;
my $kind;
my $preserve_columns;
my $verbose;
my $force;

GetOptions(
    "help|h" => sub { usage; exit 0 },
    "container|c" => sub { $action = "get-container" },
    "delete|d" => sub { $action = "delete"; },
    "field|F=s" => sub {
        my ($name,$exprs) = @_;
        for my $expr (split ',', $exprs) {
            my ($column_number,$match,@rest) = split '=',$expr;
            die "bad match expr\n" if scalar @rest;
            die "bad match expr\n" unless $column_number;
            die "bad match expr\n" unless $match;
            $match_column{$column_number} = $match;
        }
    },
    "follow" => \$follow,
    "force|f" => \$force,
    "get|g" => sub { $action = "get"; },
    "getx" => sub { $action = "getx"; },
    "logs" => sub { $action = "logs" },
    "preserve-columns|P" => \$preserve_columns,
    "shell|s=s" => sub {
        my ($name,$value) = @_;
        $action = "shell";
        $container = $value;
    },
    "verbose|v!" => \$verbose,
    "<>" => \&add_arg)
or die "error in command line arguments\n";

push @args, @ARGV;

if ($action eq "shell") {
    die "provide at least 1 argument (resource kind plus shell arguments) for shell" if scalar @args < 1;
}
else {
    die "provide 1 argument (resource kind)" if scalar @args != 1;
}

$kind = shift @args // die "please provide resource kind\n";

if ($action eq "logs" and $kind ne "pod") {
    die "--logs is only compatible with kind 'pod' (note: use singular name only)";
}

my $command = qq(kubectl get "$kind" -A -o wide);
my $pid = open(my $fh, "-|", $command) or die "$!";

# The tricky thing about the default kubectl output is that it is fixed width
# upon generation, but those widths can change, plus values can either be
# omitted or have spaces in them, which makes using awk tricky later.  Here, we
# standardize the output to be tab-separated with the column names.
#
# This will return a hash with data and lengths as arrays (guaranteed same
# length), and format (to pack and unpack the data).  Each length is the total
# length of each column slice.
sub parse_fixed_width_data {
    my ($fh) = @_;
    my $header = <$fh>;

    my @data = ();
    my @data_lengths = ();
    my @datum = ();
    while (1) {
        my $match = $header =~ /^([-A-Z0-9_]+ +)/;
        last unless $match;
        $header =~ s/^([-A-Z0-9_]+ +)//;
        my $length = length $1;
        #$length -= 1;
        my $name = $1;
        $name =~ s/ +$//;

        push @datum, $name;
        push @data_lengths, $length;
    }
    push @data, \@datum;

    my $format = "";
    my $formatted_header = "";
    for my $length (@data_lengths) {
        $format = "${format}A$length ";
    }
    chop $format;

    OUTER: while (<$fh>) {
        my @datum = unpack $format;
        push @data, \@datum;
    }

    my $ret = {
        data => \@data,
        lengths => \@data_lengths,
        format => $format,
    };
    return $ret;
}
my $parsed = parse_fixed_width_data $fh;
my @data = @{$parsed->{data}};
my @data_lengths = @{$parsed->{lengths}};
my $fmt = $parsed->{format};
my $is_namespaced = $data[0][0] eq "NAMESPACE";

my $count = -1;
OUTER: for my $datum (@data) {
    ++$count;
    if ($count) {
        for my $key (keys %match_column) {
            my $match_expr = $match_column{$key};
            if (substr($match_expr,0,1) eq "!") {
                $match_expr = substr($match_expr,1);
                next OUTER if $datum->[$key-1] =~ /$match_expr/;
            }
            else {
                next OUTER unless $datum->[$key-1] =~ /$match_expr/;
            }
            #warn "$datum->[$key-1] =~ /$match_expr/";
        }
    }

    if ($action eq "logs") {
        next unless $count;
        my $namespace = $datum->[0];
        my $name = $datum->[1];
        my @command;
        push @command, "kubectl";
        push @command, "logs";
        push @command, "-n";
        push @command, $namespace;
        push @command, $name;
        push @command, "--timestamps=true";
        push @command, "--all-containers=true";
        push @command, "--follow=true" if $follow;
        system(@command);
    }
    elsif ($action eq "get") {
        if ($preserve_columns) {
            my $line = pack $fmt, @$datum;
            say $line;
        }
        else {
            say join "\t",@$datum;
        }
    }
    elsif ($action eq "shell") {
        next unless $count;
        die "type should be pod for shell action\n" unless $kind eq "pod";
        my $namespace = $datum->[0];
        my $name = $datum->[1];
        unless ($container) {
            my @containers = get_containers $namespace, $name;
            my $container = $containers[0]->{container}{name};
            warn "warning: container automatically set to '$container'";
        }

        my @command;
        push @command, "kubectl";
        push @command, "exec";
        push @command, "-n";
        push @command, $namespace;
        push @command, $name;
        push @command, "-c";
        push @command, $container;
        push @command, "-it";
        push @command, "--";
        if (@args) {
            push @command, @args
        }
        else {
            push @command, "/bin/sh";
        }
        system(@command);
        my $status = $? >> 8;
        if (not $force and $status) {
            warn "error: last command exited with status $status.  Exiting (use --force to ignore)";
            exit $status;
        }
    }
    elsif ($action eq "get-container") {
        next unless $count;
        die "type should be pod for shell action\n" unless $kind eq "pod";
        my $namespace = $datum->[0];
        my $name = $datum->[1];
        my $yaml = qx(kubectl get pod -n "$namespace" "$name" -o yaml);
        my $resource = Load $yaml;
        say "NAMESPACE\tNAME\tCONTAINER";
        for my $container (@{$resource->{spec}{containers}}) {
            say "$namespace\t$name\t$container->{name}";
        }
    }
    elsif ($action =~ /^getx?/) {
        next unless $count;
        my $real_action;
        if ($action eq "getx") {
            $real_action = "get";
        }
        my $namespace;
        my $name;
        if ($is_namespaced) {
            $namespace = $datum->[0];
            $name = $datum->[1];
        }
        else {
            $name = $datum->[0];
        }
        my @command;
        push @command, "kubectl";
        push @command, $real_action // $action;
        push @command, $kind;
        if ($namespace) {
            push @command, "-n";
            push @command, $namespace;
        }
        push @command, $name;
        if ($action eq "delete" and not $force) {
            my $response = "";
            while (1) {
                if ($namespace) {
                    print qq;really delete $kind in namespace $namespace with name $name? (y/n) ;;
                }
                else {
                    print qq;really delete $kind with name $name? (y/n) ;;
                }
                $response = <STDIN>;
                chomp $response;
                if ($response =~ /y|n/) {
                    last;
                }
                say "y or n only.  Retry.";
            }

            if ($response ne "y") {
                say "skipping";
                next;
            }
        }
        system(@command);
    }
    else {
        die "unknown action '$action'";
    }
}

warn "warning: no matches (check match conditions?)\n" unless scalar @data > 1;

close $fh or die "$!";
